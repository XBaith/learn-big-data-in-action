# 最小生成树
最小生成树是指有权连通图中所有生成树中，边的权值和最小的生成树。

## 实现
###切分定理
- 将图中顶点分为两部分的状态，就称为一个切分

- 横切边：如果一个边的两个顶点，属于切分不同的两边，这个边就称为横切边。

- 二分图：找到一个切分，所有边都是横切边

**横切边中的最短边，属于最小生成树的边**

### Kruskal算法
算法思想：本质是贪心算法。**每次选一个最短边，如果加上这个边图中没有形成环，
那么相当于找到一个切分使得这两个顶点属于不同部分，并让这条边成为一条最短横切边，也就说明这条边属于最小生成树的边。**

判断条件：
1. 图是联通的
2. 新取出的边是否与之前取出的其他边形成环
    1. 首先可以用dfs判断顶点v到w是否连通，每次都是O(V+E)；
    2. 因为最小生成树构造过程中是**动态**判断是否有环的，所以用并查集或者堆更加高效

时间复杂度：算法时间的主要在边的排序，dfs为(V+E)，并查集是O(5)左右，最后就为O(ElogE)

### Prim算法
算法思想：同样根据切分定理
**从一个顶点出发，将这个点与其他顶点形成不同的部分也就是切分，此时该顶点的邻接边就是横切边，找到权值最小的边，
再将新的顶点也纳入同一部分形成新的切分，再找到新顶点的最小横切边，如果新加入的横切边会形成环就不考虑。
以此类推，直至所有顶点属于同一集合。**

判断条件：
1. 图是联通的
2. 新顶点的横切边是否与之前横切边形成环，如果是就将之前的横切边去除，不参与比较。
    其中Prim通过判断顶点是否遍历过来避免形成环
    
时间复杂度：执行v-1次，且每次判断最小横切边花费O(V+E),最后得到O((V-1) * (V+E)) = O(VE)

#### 优化Prim
用一个优先队列来存储待处理的横切边，每次取出最小的横切边，先检查取出的横切边是否会形成环（两个顶点都遍历过），再放入最小生成树的边集合中；
得到新的最小横切边的另外一个顶点，将这个顶点的所有横切边加入优先队列；
此时把新顶点划分到切分的一部分。完成后下次再取出横切边的最小横切边，以此类推。

时间复杂度：每条边都会进入优先队列O(E)，对于优先队列，取出和加入都是logE，所以为O(ElogE)
