# 桥

**定义**：对于无向图，如果删除一条边，整个图的连通分量数量变化，则称这条边为桥。
例如：
```
        0 
      /  \
     1    2
      \  /
       3    
     [/] 
     5
    / \ 
   4——6
```
其中3->5的边就是桥

- 对于一棵树，所有边都是桥
- 使用DFS就可以解决寻找桥的算法

## 寻找桥的算法
**判断v-w的边是否是桥，通过w能否从另外一条边回到v或者v之前的顶点。**
1. 记录每个顶点的遍历次序，存入order[]:int
2. 记录每个顶点从另一条路能够达到的最低的order值，存入low[]:int

### 实现过程
**step1**:order[0] = 0; low[0] = 0

**step2**:order[1] = 1; low[1] = 1

**step3**:order[3] = 2; low[3] = 2

**step4**:order[2] = 3; low[2] = 3

**step5**:遍历2的邻接顶点0,0不是2的父亲结点，0已经遍历过了，order[0] = 0 < order[2] = 3 => 更新low[2] = low[0] = 0。
说明通过2的能到达更低的顶点为0

**step6**:更新low[3] = low[2] = 0; 对于3->2的边，low[3] <= order[2]说明这条边能够到达更低的顶点，所以这条边就不是桥

**step7**:order[5] = 4, low[5] = 4; 遍历邻接顶点3是父节点不做处理，遍历4结点

**step8**:order[4] = 5, low[4] = 5

**step9**:order[6] = 6, low[6] = 6; 遍历邻接顶点5不是父结点，5已经遍历过了，比较low后更新low[6] = low[5] = 4

**step10**:退回到顶点4，更新low[4] = low[6] = 4
...

**step11**:退回到顶点3，low[5] !<= order[3],说明3->5这条边不能通过5到达比3更前的顶点，说明这条边就是桥

**step12**:退回到顶点2，更新low[2] = low[3] = 0，直至退回到0顶点结束

## 图的遍历树
只能由DFS找到桥，BFS做不到

- 对于上述的一个图，通过DFS得到的遍历树
```
        0               0
      /                 \
     1    2              1
      \  /                \ 
       3        =>         3 
      /                   / \
     5                   2   5
    /                       / 
   4——6                    4
                            \
                             6               
```
非遍历树的边（后向边）2->0,6->5,指向的是祖先结点

- 而BFS得到的遍历树，其结点不能指向祖先结点，只能横向指到非祖先结点
```
        0
      /  \
     1    2
      \
       3
      /
     5
    / \
   4   6
```
非遍历树的边（横向边）2->3,4->6

**综上所述**：DFS能够找到之前的顶点，从而更新low[]，可以得到桥的判断依据；
而BFS只能横向指，回不到之前遍历次序更最的结点，也就得不到判断桥的依据。 

# 割点
**对于无向图，如果删除了一个顶点（领边也删除）整个连通分量数量发生变化，则称这个顶点是割点。**

## 判断
1. low[w] >= order[v]
2. 对于根节点需要判断孩子节点是否多于1个（遍历过的结点，即使根结点与遍历过的结点有连接边，也不能算孩子结点）